package reader;

import com.opencsv.CSVReader;
import com.opencsv.exceptions.CsvException;

import java.io.FileReader;
import java.io.IOException;
import java.util.*;
import java.util.logging.Logger;

public class SystemCallDataCsvReader {
  private static final Logger LOGGER = Logger.getLogger(SystemCallDataCsvReader.class.getName());

  private final String filePath;

  public SystemCallDataCsvReader(String filePath) {
    this.filePath = filePath;
  }

  public SystemCallData read() {
    Set<String> systemCalls = new HashSet<>();
    Map<String, Map<String, Integer>> data = new LinkedHashMap<>();
    List<MalwareType> malwareTypes = new ArrayList<>();
    Map<String, Integer> malwareTypeCounts = new HashMap<>();

    try (CSVReader reader = new CSVReader(new FileReader(filePath))) {
      List<String[]> rows = reader.readAll();
      Collections.shuffle(rows);

      for (String[] row : rows) {
        for (int i = 0; i < row.length; i++) {
          row[i] = stripAfterSpace(row[i]);
        }
        int malwareTypeIndex = row.length - 1;
        String malwareType = row[malwareTypeIndex];

        malwareTypeCounts.merge(malwareType, 1, Integer::sum);

        malwareTypes.add(new MalwareType(malwareType, Arrays.stream(row).toList()));

        setUniqueSystemCalls(systemCalls, row, malwareTypeIndex);

        Map<String, Integer> systemCallCounts = new HashMap<>();
        systemCallCounts = getSystemCallCounts(data, row, malwareTypeIndex, malwareType, systemCallCounts);
        data.put(malwareType, systemCallCounts);
      }
    }
    catch (IOException | CsvException e) {
      LOGGER.severe("Failed to read data from file." + e);
    }

    Map<String, Integer> mlwNtCallFrequencyResultMap = new HashMap<>();
    Map<String, Integer> cleanNtCallFrequencyResultMap = new HashMap<>();
    for (String ntCall: systemCalls) {
      mlwNtCallFrequencyResultMap.put(ntCall, 0);
      cleanNtCallFrequencyResultMap.put(ntCall, 0);
    }
    for (Map.Entry<String, Map<String, Integer>> entry : data.entrySet()) {
      if (entry.getKey().equals("Clean")) {
        for (Map.Entry<String, Integer> ntEntry : entry.getValue().entrySet()) {
          cleanNtCallFrequencyResultMap.merge(ntEntry.getKey(), ntEntry.getValue(), Integer::sum);
        }
      }
      else {
        for (Map.Entry<String, Integer> ntEntry : entry.getValue().entrySet()) {
          mlwNtCallFrequencyResultMap.merge(ntEntry.getKey(), ntEntry.getValue(), Integer::sum);
        }
      }
    }
    return SystemCallData.builder()
        .malwareNtCallsCounts(mlwNtCallFrequencyResultMap)
        .cleanNtCallsCounts(cleanNtCallFrequencyResultMap)
        .malwareTypes(malwareTypes)
        .malwareTypeCounts(malwareTypeCounts)
        .uniqueSystemCalls(systemCalls)
        .systemCallCounts(data)
        .build();
  }

  private Map<String, Integer> getSystemCallCounts(Map<String, Map<String, Integer>> data, String[] row, int malwareTypeIndex, String malwareType, Map<String, Integer> systemCallCounts) {
    if (data.containsKey(malwareType)) {
      systemCallCounts = getSystemCallCountsForExistingMalware(data, row, malwareTypeIndex, malwareType);
    }
    else {
      getSystemCallCountsForNewMalware(row, malwareTypeIndex, systemCallCounts);
    }
    return systemCallCounts;
  }

  private void getSystemCallCountsForNewMalware(String[] row, int malwareTypeIndex, Map<String, Integer> systemCallCounts) {
    for (int i = 0; i < malwareTypeIndex; i++) {
      String systemCall =row[i];
      if (systemCallCounts.containsKey(systemCall)) {
        systemCallCounts.put(systemCall, systemCallCounts.get(systemCall) + 1);
      }
      else {
        systemCallCounts.put(systemCall, 1);
      }
    }
  }

  private Map<String, Integer> getSystemCallCountsForExistingMalware(Map<String, Map<String, Integer>> data, String[] row, int malwareTypeIndex, String malwareType) {
    Map<String, Integer> systemCallCounts = data.get(malwareType);
    for (int i = 0; i < malwareTypeIndex; i++) {
      String systemCall = row[i];
      if (systemCallCounts.containsKey(systemCall)) {
        systemCallCounts.put(systemCall, systemCallCounts.get(systemCall) + 1);
      }
      else {
        systemCallCounts.put(systemCall, 1);
      }
    }
    return systemCallCounts;
  }

  private boolean containsDetailsNotKnown(String systemCall) {
    return systemCall.endsWith("(details not all known)");
  }

  private String stripAfterSpace(String systemCall) {
    if (containsDetailsNotKnown(systemCall)) {
      return systemCall.substring(0, systemCall.indexOf(" "));
    }
    return systemCall;
  }

  private void setUniqueSystemCalls(Set<String> systemCalls, String[] row, int malwareTypeIndex) {
    systemCalls.addAll(Arrays.asList(row).subList(0, malwareTypeIndex));
  }
}
