package lt.sfc;

import lombok.Data;
import reader.GroupedSystemCall;
import reader.MalwareRisk;
import reader.MalwareType;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.List;

public class ImagePrinter {
  //image printing is top to bottom, e.g. most top value in image is first sequence value.
  private static final int WIDTH = 30;
  private static final int HEIGHT = 1000;

  private final List<GroupedSystemCall> groupedSystemCalls;
  private final List<MalwareType> malwareTypes;

  public ImagePrinter(List<GroupedSystemCall> groupedSystemCalls, List<MalwareType> malwareTypes) {
    this.groupedSystemCalls = groupedSystemCalls;
    this.malwareTypes = malwareTypes;
  }

  public void print() throws IOException {
    BufferedImage bufferedImage = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);
    for (int i = 0; i < malwareTypes.size(); i++) { //vykdoma objektų iteracija, kuriuose yra išsaugoti duomenų rinkinio įrašai
      MalwareType malwareType = malwareTypes.get(i);
      Graphics2D g2d = bufferedImage.createGraphics();

      for (int j = 0; j < malwareType.getSequence().size() - 1; j++) { //vykdoma sisteminių funkcijų iteracija
        String ntApi = malwareType.getSequence().get(j);
        var groupedSystemCall = getGroupedSystemCallByNtApi(ntApi);
        //gaunamas sisteminės funkcijos rezultatas, kuris nurodo rizikingumą

        g2d.setColor(groupedSystemCall.map(GroupedSystemCall::getColor).orElseThrow());
        g2d.drawLine(0, j, WIDTH, j);//spausdinama eilutė
      }
      g2d.dispose();

      String fileName = "pic" + MalwareRisk.getRiskScoreMultiplier() + "\\" + malwareType.getType() + i + ".png";
      File file = new File(fileName);
      ImageIO.write(bufferedImage, "png", file);//išsaugojamas sukurtas paveikslėlis iš funkcijų sekos
    }
  }

  public void printGrouped() throws IOException {
    Map<String, List<NtApiGroupCounter>> mostCommonSequence = new HashMap<>();

    for (MalwareType malwareType : malwareTypes) { //vykdoma objektų iteracija, kuriuose yra išsaugoti duomenų rinkinio įrašai
      List<NtApiGroupCounter> malwareRiskListCounter;
      boolean wasMalwareRiskListCounterEmpty;
      if (mostCommonSequence.containsKey(malwareType.getType())) {
        malwareRiskListCounter = mostCommonSequence.get(malwareType.getType());
        wasMalwareRiskListCounterEmpty = false;
      }
      else {
        malwareRiskListCounter = new ArrayList<>();
        wasMalwareRiskListCounterEmpty = true;
      }

      for (int j = 0; j < malwareType.getSequence().size() - 1; j++) { //vykdoma sisteminių funkcijų iteracija
        String ntApi = malwareType.getSequence().get(j);
        var groupedSystemCall = getGroupedSystemCallByNtApi(ntApi);
        //gaunamas sisteminės funkcijos rezultatas, kuris nurodo rizikingumą

        NtApiGroup ntApiGroup = groupedSystemCall.map(GroupedSystemCall::getKey).orElseThrow();
        if (wasMalwareRiskListCounterEmpty) {
          malwareRiskListCounter.add(new NtApiGroupCounter(ntApiGroup));
        }
        else {
          var ntApiGroupCounter = malwareRiskListCounter.get(j);
          ntApiGroupCounter.increase(ntApiGroup);
        }
      }
      mostCommonSequence.put(malwareType.getType(), malwareRiskListCounter); //išsaugomas sulietas kiekvieno indekso rezultatas
    }

    Map<String, GroupedRiskCounter> groupedRiskCounterMap = new HashMap<>();
    Map<String, GroupedRiskCounter> groupedMaxOnlyRiskCounterMap = new HashMap<>();
    BufferedImage bufferedImage = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);
    for (var entry : mostCommonSequence.entrySet()) { //vykdoma sugeneruoto bendro duomenų rinkinio iteracija kiekvienam tipui
      Graphics2D g2d = bufferedImage.createGraphics();

      GroupedRiskCounter groupedRiskCounter = new GroupedRiskCounter();
      GroupedRiskCounter groupedMaxRiskCounter = new GroupedRiskCounter();
      for (int j = 0; j < entry.getValue().size(); j++) {
        groupedRiskCounter.add(entry.getValue().get(j));
        groupedMaxRiskCounter.addMax(entry.getValue().get(j));

        var groupedSystemCall = getGroupedSystemCallByNtApiGroup(entry.getValue().get(j).getLargestCounter());
        g2d.setColor(groupedSystemCall.map(GroupedSystemCall::getColor).orElseThrow());
        g2d.drawLine(0, j, WIDTH, j);//spausdinama eilutė
      }
      g2d.dispose();
      groupedRiskCounterMap.put(entry.getKey(), groupedRiskCounter);
      groupedMaxOnlyRiskCounterMap.put(entry.getKey(), groupedMaxRiskCounter);

      String fileName = "G:\\Downloads\\demo\\malwareDataReader\\src\\main\\resources\\grouped"+ MalwareRisk.getRiskScoreMultiplier() + "\\" + entry.getKey() +"GROUPED.png";
      File file = new File(fileName);
      ImageIO.write(bufferedImage, "png", file);//išsaugojamas paveikslėlis sukurtas iš funkcijų sekos
    }
    System.out.println(":)");
  }

  private Optional<GroupedSystemCall> getGroupedSystemCallByNtApi(String ntApi) {
    return Optional.of(groupedSystemCalls.stream().filter(groupedSystemCall -> groupedSystemCall.getGroupedSystemCalls().contains(ntApi)).findFirst().orElseThrow(() -> new RuntimeException(ntApi)));
  }

  private Optional<GroupedSystemCall> getGroupedSystemCallByNtApiGroup(NtApiGroup ntApiGroup) {
    return Optional.of(groupedSystemCalls.stream().filter(groupedSystemCall -> groupedSystemCall.getKey().equals(ntApiGroup)).findFirst().orElseThrow(() -> new RuntimeException(ntApiGroup.toString())));
  }

  @Data
  class NtApiGroupCounter {
    private Map<NtApiGroup, Integer> ntApiGroupMap = new HashMap<>();

    public NtApiGroupCounter(NtApiGroup ntApiGroup) {
      addInitialValue(ntApiGroup);
    }

    public void increase(NtApiGroup ntApiGroup) {
      if (ntApiGroupMap.containsKey(ntApiGroup)) {
        ntApiGroupMap.merge(ntApiGroup, 1, Integer::sum);
      }
      else {
        addInitialValue(ntApiGroup);
      }
    }

    public NtApiGroup getLargestCounter() {
      return ntApiGroupMap.entrySet().stream().max((entry1, entry2) -> entry1.getValue() > entry2.getValue() ? 1 : -1).orElseThrow().getKey();
    }

    private void addInitialValue(NtApiGroup ntApiGroup) {
      ntApiGroupMap.put(ntApiGroup, 1);
    }
  }

  @Data
  class GroupedRiskCounter {
    private Integer lowRiskCounter = 0;
    private Integer mediumRiskCounter = 0;
    private Integer highRiskCounter = 0;

    public void add(NtApiGroupCounter ntApiGroupCounter) {
      highRiskCounter += Optional.ofNullable(ntApiGroupCounter.getNtApiGroupMap().get(NtApiGroup.HIGH)).orElse(0);
      mediumRiskCounter += Optional.ofNullable(ntApiGroupCounter.getNtApiGroupMap().get(NtApiGroup.MEDIUM)).orElse(0);
      lowRiskCounter += Optional.ofNullable(ntApiGroupCounter.getNtApiGroupMap().get(NtApiGroup.LOW)).orElse(0);
    }

    public void addMax(NtApiGroupCounter ntApiGroupCounter) {
      var largest = ntApiGroupCounter.getLargestCounter();
      if (largest.equals(NtApiGroup.HIGH)) {
        highRiskCounter += Optional.ofNullable(ntApiGroupCounter.getNtApiGroupMap().get(NtApiGroup.HIGH)).orElse(0);
      }
      else if (largest.equals(NtApiGroup.MEDIUM)) {
        mediumRiskCounter += Optional.ofNullable(ntApiGroupCounter.getNtApiGroupMap().get(NtApiGroup.MEDIUM)).orElse(0);
      }
      else {
        lowRiskCounter += Optional.ofNullable(ntApiGroupCounter.getNtApiGroupMap().get(NtApiGroup.LOW)).orElse(0);
      }
    }
  }
}
