package lt.sfc;


import com.google.common.collect.Lists;
import libsvm.LibSVM;
import net.sf.javaml.classification.Classifier;
import net.sf.javaml.classification.evaluation.CrossValidation;
import net.sf.javaml.classification.evaluation.PerformanceMeasure;
import net.sf.javaml.core.Dataset;
import net.sf.javaml.core.Instance;
import net.sf.javaml.tools.data.FileHandler;


import reader.MalwareType;
import reader.SystemCallData;


import java.io.File;
import java.util.*;

public class TrainingDataSplitter {
  private static final int SPLIT_COUNT = 5;

  private TrainingDataSplitter() {
  }

  public static List<SystemCallData> getSplits(SystemCallData allSystemCallData) throws Exception {

    List<List<MalwareType>> partitions = Lists.partition(allSystemCallData.getMalwareTypes(), allSystemCallData.getMalwareTypes().size() / SPLIT_COUNT);

    List<TrainingDataSplit> trainingDataSplits = new ArrayList<>();
    for (int i = 0; i < SPLIT_COUNT; i++) {
      List<MalwareType> malwareTypes = new ArrayList<>();
      List<MalwareType> testDataMalwareTypes = new ArrayList<>();
      for (int j = 0; j < SPLIT_COUNT ; j++) {
        if (i == j) {
          testDataMalwareTypes.addAll(partitions.get(j));
        }
        else {
          malwareTypes.addAll(partitions.get(j));
        }
      }
      trainingDataSplits.add(TrainingDataSplit.builder().data(malwareTypes).testData(testDataMalwareTypes).build());
    }


    List<SystemCallData> systemCallDatas = new ArrayList<>();
    Set<String> uniqueNtCalls = new HashSet<>();
    for (TrainingDataSplit split:trainingDataSplits) {
      Map<String, Integer> mlwNtCallFrequencyResultMap = new HashMap<>();
      Map<String, Integer> cleanNtCallFrequencyResultMap = new HashMap<>();
      var temp = split.getData();
//      temp.addAll(split.getTestData());
      for (MalwareType malwareType: temp) {
        String type = malwareType.getType();
        for (String ntCall: malwareType.getSequence()) {
          if (type.equals(ntCall)) continue;
          uniqueNtCalls.add(ntCall);
          if (type.equals("Clean")) {
            cleanNtCallFrequencyResultMap.merge(ntCall, 1, Integer::sum);
          }
          else {
            mlwNtCallFrequencyResultMap.merge(ntCall, 1, Integer::sum);
          }
        }
      }

      SystemCallData systemCallData = SystemCallData.builder()
          .cleanNtCallsCounts(cleanNtCallFrequencyResultMap)
          .malwareNtCallsCounts(mlwNtCallFrequencyResultMap)
          .malwareTypes(split.getData())
          .malwareTypesTestData(split.getTestData())
          .uniqueSystemCalls(uniqueNtCalls)
          .build();
      systemCallDatas.add(systemCallData);
    }
    return systemCallDatas;
  }

  public static List<SystemCallData> getSplitsACD(SystemCallData allSystemCallData) throws Exception {
    int rowsCount = allSystemCallData.getMalwareTypes().size();
    int rowsSplit = rowsCount / SPLIT_COUNT;

    Map<Integer, List<MalwareType>> dataSplits = new HashMap<>();
    List<MalwareType> malwareTypesSplit = new ArrayList<>();
    int currentSplitNumber = 1;
    for (int i = 1; i <= allSystemCallData.getMalwareTypes().size(); i++) {
      MalwareType malwareType = allSystemCallData.getMalwareTypes().get(i - 1);
      if (i % rowsSplit == 0) {
        if (dataSplits.containsKey(currentSplitNumber)) {
          var trainingDataSplit = dataSplits.get(currentSplitNumber);
          trainingDataSplit.addAll(malwareTypesSplit);
          dataSplits.put(currentSplitNumber, trainingDataSplit);
        }
        else {
          dataSplits.put(currentSplitNumber, malwareTypesSplit);
        }
        malwareTypesSplit = new ArrayList<>();
        currentSplitNumber++;
      }
      else {
        malwareTypesSplit.add(malwareType);
      }
    }

    List<TrainingDataSplit> trainingDataSplits = new ArrayList<>();
    for (int i = 1; i <= SPLIT_COUNT; i++) {
      List<MalwareType> malwareTypes = new ArrayList<>();
      List<MalwareType> testDataMalwareTypes = new ArrayList<>();
      for (int j = 1; j <= SPLIT_COUNT; j++) {
        if (i == j) {
          testDataMalwareTypes.addAll(dataSplits.get(j));
        }
        else {
          malwareTypes.addAll(dataSplits.get(j));
        }
      }
      trainingDataSplits.add(TrainingDataSplit.builder().data(malwareTypes).testData(testDataMalwareTypes).build());
    }

    List<SystemCallData> systemCallDatas = new ArrayList<>();
    for (TrainingDataSplit split:trainingDataSplits) {
      Map<String, Integer> mlwNtCallFrequencyResultMap = new HashMap<>();
      Map<String, Integer> cleanNtCallFrequencyResultMap = new HashMap<>();
      for (MalwareType malwareType: split.getData()) {
        String type = malwareType.getType();
        for (String ntCall: malwareType.getSequence()) {
          if (type.equals("Clean")) {
            cleanNtCallFrequencyResultMap.merge(ntCall, 1, Integer::sum);
          }
          else {
            mlwNtCallFrequencyResultMap.merge(ntCall, 1, Integer::sum);
          }
        }
      }

      SystemCallData systemCallData = SystemCallData.builder()
          .cleanNtCallsCounts(cleanNtCallFrequencyResultMap)
          .malwareNtCallsCounts(mlwNtCallFrequencyResultMap)
          .malwareTypes(split.getData())
          .malwareTypesTestData(split.getTestData())
          .build();
      systemCallDatas.add(systemCallData);
    }
    return systemCallDatas;
  }
}
