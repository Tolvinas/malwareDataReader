package lt.sfc;


import reader.*;

import java.awt.*;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;
import java.util.List;


public class Main {
  private static final int SIZE = 1000;

  public static void main(String[] args) throws Exception {
    SystemCallDataCsvReader reader = new SystemCallDataCsvReader("G:\\Downloads\\demo\\malwareDataReader\\src\\main\\resources\\" + SIZE + "_6.csv");

    SystemCallData systemCallData = reader.read(); // ALL DATA
    List<SystemCallData> allSystemCallData = List.of(systemCallData);
    List<SystemCallData> splitSystemCallData = TrainingDataSplitter.getSplits(systemCallData);

//    validateSplit(systemCallData, splitSystemCallData);
//    execute(allSystemCallData, "");
    execute(splitSystemCallData, "splitDataset");
    excelWriter(systemCallData);

  }

  private static void validateSplit(SystemCallData systemCallData, List<SystemCallData> splitSystemCallData) {
    for (MalwareType malwareType : systemCallData.getMalwareTypes()) {
      if (splitSystemCallData.get(0).getMalwareTypesTestData().contains(malwareType) ||
          splitSystemCallData.get(0).getMalwareTypes().contains(malwareType) ||
          splitSystemCallData.get(1).getMalwareTypesTestData().contains(malwareType) ||
          splitSystemCallData.get(1).getMalwareTypes().contains(malwareType) ||
          splitSystemCallData.get(2).getMalwareTypesTestData().contains(malwareType) ||
          splitSystemCallData.get(2).getMalwareTypes().contains(malwareType) ||
          splitSystemCallData.get(3).getMalwareTypesTestData().contains(malwareType) ||
          splitSystemCallData.get(3).getMalwareTypes().contains(malwareType) ||
          splitSystemCallData.get(4).getMalwareTypesTestData().contains(malwareType) ||
          splitSystemCallData.get(4).getMalwareTypes().contains(malwareType)) {
      }
      else {
        throw new RuntimeException("Missing data");
      }

    }
    for(String ntApi:systemCallData.getUniqueSystemCalls()) {
      for (SystemCallData split:splitSystemCallData) {
        int expected = systemCallData.getMalwareNtCallsCounts().get(ntApi) + systemCallData.getCleanNtCallsCounts().get(ntApi);
        int got = Optional.ofNullable(split.getMalwareNtCallsCounts().get(ntApi)).orElse(0) + Optional.ofNullable(split.getCleanNtCallsCounts().get(ntApi)).orElse(0);
        if (got != expected) {
          throw new RuntimeException("Counts are not equal:" + ntApi + ",expected" + expected + ",got" + got);
        }
      }
    }
  }

  private static void execute(List<SystemCallData> systemCallData, String filenamePostfix) throws IOException {
    int i = 0;
    for (SystemCallData data : systemCallData) {
      NtCallRisk ntCallRisk = ntCallRiskCounter(data);
      if (data.getMalwareTypesTestData() != null) {
        generateGroupedDataset(data.getMalwareTypesTestData(), ntCallRisk.getRiskScoreForNtCall(), filenamePostfix + "Test" + i);
      }
      generateGroupedDataset(data.getMalwareTypes(), ntCallRisk.getRiskScoreForNtCall(), filenamePostfix + i);
      imagePrinter(data, ntCallRisk.getHighRiskNtCalls(), ntCallRisk.getMediumRiskNtCalls(), ntCallRisk.getLowRiskNtCalls());

      i++;
    }
  }

  private static NtCallRisk ntCallRiskCounter(SystemCallData systemCallData) {
    Map<String, MalwareRisk> riskScoreForNtCall = new HashMap<>();
    List<String> highRiskNtCalls = new ArrayList<>();
    List<String> mediumRiskNtCalls = new ArrayList<>();
    List<String> lowRiskNtCalls = new ArrayList<>();

    for(String ntCall : systemCallData.getUniqueSystemCalls()){
      int mlwCounter = Optional.ofNullable(systemCallData.getMalwareNtCallsCounts().get(ntCall)).orElse(0);
      int cleanCounter = Optional.ofNullable(systemCallData.getCleanNtCallsCounts().get(ntCall)).orElse(0);
      double riskScore = cleanCounter == 0 ? 1000 : mlwCounter * 1.0 / cleanCounter;
      MalwareRisk malwareRisk = MalwareRisk.getMalwareRiskByRiskScore(riskScore);
      if (malwareRisk.equals(MalwareRisk.HIGH)) {
        highRiskNtCalls.add(ntCall);
      }
      else if (malwareRisk.equals(MalwareRisk.MEDIUM)) {
        mediumRiskNtCalls.add(ntCall);
      }
      else {
        lowRiskNtCalls.add(ntCall);
      }
      riskScoreForNtCall.put(ntCall, malwareRisk);
    }

    return NtCallRisk.builder()
        .riskScoreForNtCall(riskScoreForNtCall)
        .lowRiskNtCalls(lowRiskNtCalls)
        .mediumRiskNtCalls(mediumRiskNtCalls)
        .highRiskNtCalls(highRiskNtCalls).build();
  }

  private static void imagePrinter(SystemCallData systemCallData, List<String> highRiskNtCalls, List<String> mediumRiskNtCalls, List<String> lowRiskNtCalls) throws IOException {
    List<GroupedSystemCall> groupedSystemCalls = new ArrayList<>();
    groupedSystemCalls.add(GroupedSystemCall.builder().key(NtApiGroup.HIGH).color(Color.RED).groupedSystemCalls(highRiskNtCalls).build());
    groupedSystemCalls.add(GroupedSystemCall.builder().key(NtApiGroup.MEDIUM).color(Color.YELLOW).groupedSystemCalls(mediumRiskNtCalls).build());
    groupedSystemCalls.add(GroupedSystemCall.builder().key(NtApiGroup.LOW).color(Color.GREEN).groupedSystemCalls(lowRiskNtCalls).build());

    ImagePrinter imagePrinter = new ImagePrinter(groupedSystemCalls, systemCallData.getMalwareTypes());
    imagePrinter.print();
//    imagePrinter.printGrouped();
  }

  private static void generateGroupedDataset(List<MalwareType> malwareTypes, Map<String, MalwareRisk> riskScoreForNtCall, String filenamePostfix) throws IOException {
    FileWriter fileComp = new FileWriter("groupedByRiskScoreSize" + SIZE + "Multiplier" + MalwareRisk.getRiskScoreMultiplier() + filenamePostfix + ".csv");
    PrintWriter writeComp = new PrintWriter(fileComp);

    for (MalwareType malwareType : malwareTypes) {
      List<String> dataToWrite = new ArrayList<>();
      for (String sequenceValue : malwareType.getSequence()) {
        if (riskScoreForNtCall.containsKey(sequenceValue) || !List.of("Clean", "Adware", "DangerousObject", "Downloader", "Trojan", "WebToolbar").contains(sequenceValue)) {
          MalwareRisk malwareRisk = riskScoreForNtCall.get(sequenceValue);
          dataToWrite.add(String.valueOf(Optional.ofNullable(malwareRisk).map(MalwareRisk::getRiskScoreIntValue).orElse(MalwareRisk.LOW.getRiskScoreIntValue())));
        }
      }
      dataToWrite.add(malwareType.getType());
      writeComp.println(String.join(",", dataToWrite));
    }
    fileComp.close();
  }

  private static void excelWriter(SystemCallData systemCallData) throws IOException {
    FileWriter fileComp = new FileWriter("comparison.csv");
    PrintWriter writeComp = new PrintWriter(fileComp);
    writeComp.println(String.join(",", new String[]{"ntCall", "malwareCnt", "cleanCnt", "riskScore"}));

    for (Map.Entry<String, Integer> mlwEntry : systemCallData.getMalwareNtCallsCounts().entrySet()) {
      String ntCall = mlwEntry.getKey();
      int mlwCounter = mlwEntry.getValue();
      int cleanCounter = systemCallData.getCleanNtCallsCounts().get(ntCall);
      double riskScore = cleanCounter == 0 ? 1000 : mlwCounter * 1.0 / cleanCounter;
      writeComp.println(String.join(",", new String[]{mlwEntry.getKey(), String.valueOf(mlwCounter), String.valueOf(cleanCounter), String.valueOf(riskScore)}));
      //iki 4.25 safe
      //
    }
    writeComp.close();

//    FileWriter fileMlw = new FileWriter("mlw.csv");
//    PrintWriter writeMlw = new PrintWriter(fileMlw);
//    for (Map.Entry<String, Integer> ntEntry : mlwCountResultMap.entrySet()) {
//      writeMlw.println(String.join(",", new String[]{ntEntry.getKey(), ntEntry.getValue().toString()}));
//    }
//    writeMlw.close();
//
//    FileWriter fileClean = new FileWriter("clean.csv");
//    PrintWriter writeClean = new PrintWriter(fileClean);
//    for (Map.Entry<String, Integer> ntEntry : cleanCountResultMap.entrySet()) {
//      writeClean.println(String.join(",", new String[]{ntEntry.getKey(), ntEntry.getValue().toString()}));
//    }
//    fileClean.close();
  }


}
